Any computer program mainly consists of two parts:

1. Data → Variables

2. Logic → Functions / Methods

--Among these two, data is the most critical part, because:

-Logic can be rewritten

-But data loss or corruption is dangerous


Problem with Procedural / Structured Programming:
-------------------------------------------------

In procedural or structured programming languages (like C/C++):

--Data is often declared as global variables

--Global variables can be accessed and modified by any function

--This leads to high data insecurity

Example: Banking Application (Procedural Style)


// bankingApp.cpp

string customerName;
int accountNumber;
int balance;
string branchName;

void withdraw(int amt) {
    balance = balance - amt;
}

void deposit(int amt) {
    balance = balance + amt;
}

void transferAmount(int src, int dest, int amt) {
    // transfer logic
}

void login() {
    // authentication & authorization
}

void logout() {
}

void changePassword() {
    // unrelated function accessing unrelated data
    balance = balance - 5000;
}



Problems in Above Code:
-----------------------

--balance is globally accessible

--Any function (even unrelated ones) can modify it

Example: changePassword() modifying balance

Leads to:

--Data corruption

--Security issues

--Poor maintainability


To secure data, programmers designed a mechanism where:

--Data and the functions that operate on that data are bound together inside a single unit.

--This unit is called a Class.

--This concept is known as Encapsulation.



Object-Oriented Solution Using Encapsulation:
---------------------------------------------


class Account {

    private String customerName;
    private int accountNumber;
    private int balance;
    private String branchName;

    void withdraw(int amt) {
        balance = balance - amt;
    }

    void deposit(int amt) {
        balance = balance + amt;
    }

    void transferAmount(int src, int dest, int amt) {
        // transfer logic
    }
}


class Authentication {

    void login() {
        // authentication & authorization
    }

    void logout() {
    }

    void changePassword() {
        // cannot access Account balance directly
    }
}



Key Observations:

1. Data Security

--balance is private

--Cannot be accessed outside Account class

--Only related methods can modify it

2. Separation of Responsibility

--Account → Financial operations

--Authentication → Login / security operations

3. No Global Variables

--Variables inside a class are not global

--They are also not local to a single method

--Hence, they are called Instance Variables


Pure Encapsulation:
-------------------

--A class is said to be purely encapsulated when all data members are declared as private.

--Account class is a purely encapsulated class

--It acts as a blueprint

--Multiple objects (accounts) can be created with different states



Definition of Encapsulation:
-----------------------------

--Encapsulation is the process of binding data along with its corresponding functionalities and restricting direct access to data to ensure security.



Purpose of Encapsulation:
-------------------------

--Data security

--Controlled access

--Better maintainability

--Modular design



Java supports all the 4 pillers of  OOP concepts:

1. Encapsulation

2. Inheritance

3. Polymorphism

4. Abstraction

Hence, Java is an Object-Oriented Programming language



Note: C++ also supports encapsulation but it also allows:

--Global variables

--Global functions

Therefore, C++ is not considered a pure OOP language

--Java avoids this by forcing everything inside classes



--Encapsulation was the first step in the evolution of OOP

--It protects data from unauthorized access

--It eliminates the problems of global variables

--It forms the backbone of Object-Oriented Programming






JDK and OpenJDK:
----------------

To develop and run a Java application, we need to install a software called the JDK (Java Development Kit).

--The official JDK is provided by Oracle through its website.

--Oracle JDK is free for development, but license required for some production use.

--Apart from Oracle, many other vendors also provide their own JDK distributions.

Some popular JDK vendors are:

-Amazon Corretto

-Azul Systems

-Eclipse Temurin (Adoptium)

-IBM Semeru JDK

-Red Hat OpenJDK


Example: Amazon Corretto JDK Installation

--If Amazon Corretto JDK is installed, the environment variables are usually set as:

JAVA_HOME = C:\Program Files\Amazon Corretto\jdk21.0.9_10
Path      = C:\Program Files\Amazon Corretto\jdk21.0.9_10\bin


--JAVA_HOME points to the JDK installation directory

--Path allows us to run Java commands (java, javac) from anywhere in the terminal


Java Editions (Categories):

--Java is divided into three main editions:

1. Java SE (Standard Edition)

--Also called Core Java

--Provides fundamental APIs such as OOP, collections, multithreading, exception handling, JDBC, etc.

2. Java EE (Enterprise Edition) (now called Jakarta EE)

--Also known as Advanced Java

--Used for enterprise and web applications

--Built on top of Java SE

3. Java ME (Micro Edition)

--Used for embedded systems and resource-constrained devices


Note: Java SE is the base edition for both Java EE and Java ME.


Java as a Specification:
------------------------

--All Java editions (SE, EE, ME) are specifications, not direct software.

--A specification is a detailed document that defines:

-Rules

-APIs

-Behavior

-Guidelines to develop Java software

--Java SE Specification defines what features a Java SE platform must support.


JDK and OpenJDK:
----------------

--The implementation of the Java SE specification is called the JDK.

--OpenJDK is the reference implementation of the Java SE specification.

--Most vendors (Oracle, Amazon, Azul, etc.) build their JDKs using OpenJDK source code, with some additional optimizations or support.



Analogy:
--------

CBSE Syllabus:	Java SE Specification
NCERT Book:	OpenJDK (Reference Implementation)
Other Publishers’ Books	Vendor JDKs (Amazon Corretto, Oracle JDK, etc.)


Just like:

--NCERT strictly follows the CBSE syllabus

--OpenJDK strictly follows the Java SE specification

--Other publishers/vendors release their own versions based on the same standard


******************************************************************************************************************

Java First Program

Program1.java
--------------

class Demo {

    public static void main(String[] args) {
        System.out.println("Welcome to Chitkara");
    }

}


Java Class Naming Convention:
-----------------------------

--Java class names should start with a capital letter.

--Java follows PascalCase (PascalNaming Convention) for class names.


Examples:

class StudentDetails { }
class BankAccount { }


Tip: In Java applications, anything that starts with a capital letter is usually (almost always) a class or an interface.


Phases of Java Program Execution:
----------------------------------

--To execute a Java program, there are two phases:

1. Compilation Phase

2. Execution (Run) Phase


(source code)	compiler			(byte code)	
.java----------->compile----------------------->.class------------>executed by the JVM
		 javac 							java ClassName
		javac file_name.java


Command to compile:
-------------------

javac FileName.java



Bytecode and JVM Execution:
---------------------------

--The .class file contains bytecode.

--Bytecode is executed by the JVM (Java Virtual Machine).




Multiple Classes in a Single .java File:
----------------------------------------

--A single .java file can contain multiple classes.

--For each class, the compiler generates a separate .class file.

Example

Program1.java
-------------

class Demo1 {

    public static void main(String[] args) {
        System.out.println("Welcome to Chitkara1");
    }
}

class Demo2 {

    public static void main(String[] args) {
        System.out.println("Welcome to Chitkara2");
    }
}

class Demo3 {

    public static void main(String[] args) {
        System.out.println("Welcome to Chitkara3");
    }
}



After Compilation:
------------------

Demo1.class
Demo2.class
Demo3.class


Execution:
----------

java Demo1
java Demo2
java Demo3


--Only one class is executed at a time
--That class must contain main()


Empty Java Class:
-----------------

--A Java class can exist without any members.

--An empty class is syntactically valid, but cannot be executed.

Example:

class Demo {
    // Empty class
}


.class file will be generated
--Cannot run (no main() method)


main() Method Rule:
------------------

--Only classes containing:

public static void main(String[] args)


--can be executed using the java command.


public Class and File Name Rule:
-------------------------------

--A .java file can contain only one public class

--If a class is declared as public:

--File name must be same as the public class name



Best Practice:
--------------

--Generally, we write one class per .java file

Makes code:

--Readable
--Maintainable
--Industry-standard


JDK, JVM, and JRE:
------------------

Platform Independence

--Java is platform independent

--JVM is platform dependent

Why?

--Java programs compile into bytecode

--Bytecode is independent of OS

--JVM converts bytecode into OS-specific machine code


.class  ---> JVM  ---> OS Executable Code


--Same .class file can run on:

Windows
Linux
macOS
(as long as JVM is available)





************************************************************************


IDE installation:
-----------------

Eclipse




Similarity of Java with Other Programming Languages:
-----------------------------------------------------

--Most of the common and fundamental programming concepts in Java are very similar to those found in other popular programming languages such as C, C++, and Python.

--These similarities make Java easy to learn, especially for students who already have basic programming knowledge.

--This helps programmers focus on object-oriented concepts rather than struggling with syntax.

--Because of this similarity, transitioning from C/C++ to Java is relatively smooth.



1. Operators:

Java supports almost the same types of operators as other programming languages:

Arithmetic Operators: +, -, *, /, %

Relational Operators: >, <, >=, <=, ==, !=

Logical Operators: &&, ||, !

Assignment Operators: =, +=, -=, *=, /=

Increment / Decrement Operators: ++, --

--These operators behave almost the same way as in languages like C and C++.


2. Conditional Statements (if, if-else, else-if):

Decision-making statements in Java follow a syntax and logic similar to other languages.

Example:


int age = 20;

if (age >= 18) {
    System.out.println("Eligible to vote");
} else {
    System.out.println("Not eligible to vote");
}


--The working of if, if-else, and else-if is conceptually identical to C/C++.


3. Looping Statements:

--Java provides looping constructs that are almost identical to those in other languages.

for Loop
--------

for (int i = 1; i <= 5; i++) {
    System.out.println(i);
}


while Loop:
----------

int i = 1;

while (i <= 5) {
    System.out.println(i);
    i++;
}



do-while Loop:
---------------

int i = 1;

do {
    System.out.println(i);
    i++;
} while (i <= 5);


--The logic and flow of loops remain same across most languages.



4. Identifiers:

--Identifiers are the names given to program elements such as:

Variables

Methods

Classes

Objects

--Rules for identifiers in Java are very similar to other languages:

1. Must start with a letter, _, or $

2. Cannot start with a digit

3. Cannot be a keyword

4. Are case-sensitive

----G7





Note: in java, local variable must be initialized before we use it.

	//local variable 	
		int z;
		
		z=100;
		
	System.out.println(z);
		

Example of conditional statements:
----------------------------------

Using if-else:

Demo.java:
----------


class Demo{

	public static void main(String[] args){

		
		int marks = 500;

		 if(marks > 600)
			 System.out.println("First Div");
		 else
			 System.out.println("Second Div");

	}

}


Without else part:


class Demo{

	public static void main(String[] args){

		
		int marks = 500;
		String result = "First Div";

		 if(marks > 600)
			 result = "Second Div";
		 
		System.out.println(result);

	}

}


Without if-else:
----------------


class Demo{

	public static void main(String[] args){

		
		int marks = 500;


		String result = (marks > 600) ? "First Div" : "Second Div";

		System.out.println(result);
			
	}

}


Task:

int x = 11;

if x value is divisible by 5 then print "Hello"  // 10
if x value is divisible by 3 then print "Welcome" // 9 
if x value is divisible by 5 and 3 then print "Hello Welcome"  // 15,30
if x value is not divisible by 5 and 3 then print "invalid number" //2,11



Solution1: 


int x = 15;

if (x % 5 == 0) {
    System.out.println("Hello");
}
else if (x % 3 == 0) {
    System.out.println("Welcome");
}
else if (x % 5 == 0 && x % 3 == 0) {
    System.out.println("Hello Welcome");
}
else {
    System.out.println("invalid number");
}


Why This Code Is Wrong?

For x = 15

x % 5 == 0 → true

Program prints "Hello"

The condition x % 5 == 0 && x % 3 == 0 is never reached

--More specific condition is placed after less specific condition

--Order of conditions is incorrect


Correct code:
-------------

int x = 15;

if (x % 5 == 0 && x % 3 == 0) {
    System.out.println("Hello Welcome");
}

else if (x % 5 == 0) {
    System.out.println("Hello");
}

else if (x % 3 == 0) {
    System.out.println("Welcome");
}

else {
    System.out.println("invalid number");
}



--In if-else ladder, always write the most specific condition first and the most general condition last.


















































































function of jvm:-
----------------
1.it converts required part of byte code into its equlivallent executable code
2.it loads the executable code into the ram.
3.executes this code through local os.
4.deletes the code from Ram.

now,if a jvm is in windows environment it converts the .class file into its equlivalent
executable code that is understand by windows environment only...
simillarly ...
thus jvm is platform dependent.
