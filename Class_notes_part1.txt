Any computer program mainly consists of two parts:

1. Data → Variables

2. Logic → Functions / Methods

--Among these two, data is the most critical part, because:

-Logic can be rewritten

-But data loss or corruption is dangerous


Problem with Procedural / Structured Programming:
-------------------------------------------------

In procedural or structured programming languages (like C/C++):

--Data is often declared as global variables

--Global variables can be accessed and modified by any function

--This leads to high data insecurity

Example: Banking Application (Procedural Style)


// bankingApp.cpp

string customerName;
int accountNumber;
int balance;
string branchName;

void withdraw(int amt) {
    balance = balance - amt;
}

void deposit(int amt) {
    balance = balance + amt;
}

void transferAmount(int src, int dest, int amt) {
    // transfer logic
}

void login() {
    // authentication & authorization
}

void logout() {
}

void changePassword() {
    // unrelated function accessing unrelated data
    balance = balance - 5000;
}



Problems in Above Code:
-----------------------

--balance is globally accessible

--Any function (even unrelated ones) can modify it

Example: changePassword() modifying balance

Leads to:

--Data corruption

--Security issues

--Poor maintainability


To secure data, programmers designed a mechanism where:

--Data and the functions that operate on that data are bound together inside a single unit.

--This unit is called a Class.

--This concept is known as Encapsulation.



Object-Oriented Solution Using Encapsulation:
---------------------------------------------


class Account {

    private String customerName;
    private int accountNumber;
    private int balance;
    private String branchName;

    void withdraw(int amt) {
        balance = balance - amt;
    }

    void deposit(int amt) {
        balance = balance + amt;
    }

    void transferAmount(int src, int dest, int amt) {
        // transfer logic
    }
}


class Authentication {

    void login() {
        // authentication & authorization
    }

    void logout() {
    }

    void changePassword() {
        // cannot access Account balance directly
    }
}



Key Observations:

1. Data Security

--balance is private

--Cannot be accessed outside Account class

--Only related methods can modify it

2. Separation of Responsibility

--Account → Financial operations

--Authentication → Login / security operations

3. No Global Variables

--Variables inside a class are not global

--They are also not local to a single method

--Hence, they are called Instance Variables


Pure Encapsulation:
-------------------

--A class is said to be purely encapsulated when all data members are declared as private.

--Account class is a purely encapsulated class

--It acts as a blueprint

--Multiple objects (accounts) can be created with different states



Definition of Encapsulation:
-----------------------------

--Encapsulation is the process of binding data along with its corresponding functionalities and restricting direct access to data to ensure security.



Purpose of Encapsulation:
-------------------------

--Data security

--Controlled access

--Better maintainability

--Modular design



Java supports all the 4 pillers of  OOP concepts:

1. Encapsulation

2. Inheritance

3. Polymorphism

4. Abstraction

Hence, Java is an Object-Oriented Programming language



Note: C++ also supports encapsulation but it also allows:

--Global variables

--Global functions

Therefore, C++ is not considered a pure OOP language

--Java avoids this by forcing everything inside classes



--Encapsulation was the first step in the evolution of OOP

--It protects data from unauthorized access

--It eliminates the problems of global variables

--It forms the backbone of Object-Oriented Programming






JDK and OpenJDK:
----------------

To develop and run a Java application, we need to install a software called the JDK (Java Development Kit).

--The official JDK is provided by Oracle through its website.

--Oracle JDK is free for development, but license required for some production use.

--Apart from Oracle, many other vendors also provide their own JDK distributions.

Some popular JDK vendors are:

-Amazon Corretto

-Azul Systems

-Eclipse Temurin (Adoptium)

-IBM Semeru JDK

-Red Hat OpenJDK


Example: Amazon Corretto JDK Installation

--If Amazon Corretto JDK is installed, the environment variables are usually set as:

JAVA_HOME = C:\Program Files\Amazon Corretto\jdk21.0.9_10
Path      = C:\Program Files\Amazon Corretto\jdk21.0.9_10\bin


--JAVA_HOME points to the JDK installation directory

--Path allows us to run Java commands (java, javac) from anywhere in the terminal


Java Editions (Categories):

--Java is divided into three main editions:

1. Java SE (Standard Edition)

--Also called Core Java

--Provides fundamental APIs such as OOP, collections, multithreading, exception handling, JDBC, etc.

2. Java EE (Enterprise Edition) (now called Jakarta EE)

--Also known as Advanced Java

--Used for enterprise and web applications

--Built on top of Java SE

3. Java ME (Micro Edition)

--Used for embedded systems and resource-constrained devices


Note: Java SE is the base edition for both Java EE and Java ME.


Java as a Specification:
------------------------

--All Java editions (SE, EE, ME) are specifications, not direct software.

--A specification is a detailed document that defines:

-Rules

-APIs

-Behavior

-Guidelines to develop Java software

--Java SE Specification defines what features a Java SE platform must support.


JDK and OpenJDK:
----------------

--The implementation of the Java SE specification is called the JDK.

--OpenJDK is the reference implementation of the Java SE specification.

--Most vendors (Oracle, Amazon, Azul, etc.) build their JDKs using OpenJDK source code, with some additional optimizations or support.



Analogy:
--------

CBSE Syllabus:	Java SE Specification
NCERT Book:	OpenJDK (Reference Implementation)
Other Publishers’ Books	Vendor JDKs (Amazon Corretto, Oracle JDK, etc.)


Just like:

--NCERT strictly follows the CBSE syllabus

--OpenJDK strictly follows the Java SE specification

--Other publishers/vendors release their own versions based on the same standard


******************************************************************************************************************

Java First Program

Program1.java
--------------

class Demo {

    public static void main(String[] args) {
        System.out.println("Welcome to Chitkara");
    }

}


Java Class Naming Convention:
-----------------------------

--Java class names should start with a capital letter.

--Java follows PascalCase (PascalNaming Convention) for class names.


Examples:

class StudentDetails { }
class BankAccount { }


Tip: In Java applications, anything that starts with a capital letter is usually (almost always) a class or an interface.


Phases of Java Program Execution:
----------------------------------

--To execute a Java program, there are two phases:

1. Compilation Phase

2. Execution (Run) Phase


(source code)	compiler			(byte code)	
.java----------->compile----------------------->.class------------>executed by the JVM
		 javac 							java ClassName
		javac file_name.java


Command to compile:
-------------------

javac FileName.java



Bytecode and JVM Execution:
---------------------------

--The .class file contains bytecode.

--Bytecode is executed by the JVM (Java Virtual Machine).




Multiple Classes in a Single .java File:
----------------------------------------

--A single .java file can contain multiple classes.

--For each class, the compiler generates a separate .class file.

Example

Program1.java
-------------

class Demo1 {

    public static void main(String[] args) {
        System.out.println("Welcome to Chitkara1");
    }
}

class Demo2 {

    public static void main(String[] args) {
        System.out.println("Welcome to Chitkara2");
    }
}

class Demo3 {

    public static void main(String[] args) {
        System.out.println("Welcome to Chitkara3");
    }
}



After Compilation:
------------------

Demo1.class
Demo2.class
Demo3.class


Execution:
----------

java Demo1
java Demo2
java Demo3


--Only one class is executed at a time
--That class must contain main()


Empty Java Class:
-----------------

--A Java class can exist without any members.

--An empty class is syntactically valid, but cannot be executed.

Example:

class Demo {
    // Empty class
}


.class file will be generated
--Cannot run (no main() method)


main() Method Rule:
------------------

--Only classes containing:

public static void main(String[] args)


--can be executed using the java command.


public Class and File Name Rule:
-------------------------------

--A .java file can contain only one public class

--If a class is declared as public:

--File name must be same as the public class name



Best Practice:
--------------

--Generally, we write one class per .java file

Makes code:

--Readable
--Maintainable
--Industry-standard


JDK, JVM, and JRE:
------------------

Platform Independence

--Java is platform independent

--JVM is platform dependent

Why?

--Java programs compile into bytecode

--Bytecode is independent of OS

--JVM converts bytecode into OS-specific machine code


.class  ---> JVM  ---> OS Executable Code


--Same .class file can run on:

Windows
Linux
macOS
(as long as JVM is available)





************************************************************************


IDE installation:
-----------------

Eclipse




Similarity of Java with Other Programming Languages:
-----------------------------------------------------

--Most of the common and fundamental programming concepts in Java are very similar to those found in other popular programming languages such as C, C++, and Python.

--These similarities make Java easy to learn, especially for students who already have basic programming knowledge.

--This helps programmers focus on object-oriented concepts rather than struggling with syntax.

--Because of this similarity, transitioning from C/C++ to Java is relatively smooth.



1. Operators:

Java supports almost the same types of operators as other programming languages:

Arithmetic Operators: +, -, *, /, %

Relational Operators: >, <, >=, <=, ==, !=

Logical Operators: &&, ||, !

Assignment Operators: =, +=, -=, *=, /=

Increment / Decrement Operators: ++, --

--These operators behave almost the same way as in languages like C and C++.


2. Conditional Statements (if, if-else, else-if):

Decision-making statements in Java follow a syntax and logic similar to other languages.

Example:


int age = 20;

if (age >= 18) {
    System.out.println("Eligible to vote");
} else {
    System.out.println("Not eligible to vote");
}


--The working of if, if-else, and else-if is conceptually identical to C/C++.


3. Looping Statements:

--Java provides looping constructs that are almost identical to those in other languages.

for Loop
--------

for (int i = 1; i <= 5; i++) {
    System.out.println(i);
}


while Loop:
----------

int i = 1;

while (i <= 5) {
    System.out.println(i);
    i++;
}



do-while Loop:
---------------

int i = 1;

do {
    System.out.println(i);
    i++;
} while (i <= 5);


--The logic and flow of loops remain same across most languages.



4. Identifiers:

--Identifiers are the names given to program elements such as:

Variables

Methods

Classes

Objects

--Rules for identifiers in Java are very similar to other languages:

1. Must start with a letter, _, or $

2. Cannot start with a digit

3. Cannot be a keyword

4. Are case-sensitive








Note: in java, local variable must be initialized before we use it.

	//local variable 	
		int z;
		
		z=100;
		
	System.out.println(z);
		

Example of conditional statements:
----------------------------------

Using if-else:

Demo.java:
----------


class Demo{

	public static void main(String[] args){

		
		int marks = 500;

		 if(marks > 600)
			 System.out.println("First Div");
		 else
			 System.out.println("Second Div");

	}

}


Without else part:


class Demo{

	public static void main(String[] args){

		
		int marks = 500;
		String result = "First Div";

		 if(marks > 600)
			 result = "Second Div";
		 
		System.out.println(result);

	}

}


Without if-else:
----------------


class Demo{

	public static void main(String[] args){

		
		int marks = 500;


		String result = (marks > 600) ? "First Div" : "Second Div";

		System.out.println(result);
			
	}

}


Task:

int x = 2;

if x value is divisible by 5 then print "Hello"  // 10
if x value is divisible by 3 then print "Welcome" // 9 
if x value is divisible by 5 and 3 then print "Hello Welcome"  // 15,30
if x value is not divisible by 5 and 3 then print "invalid number" //2,11





Solution1: 


int x = 15;

if (x % 5 == 0) {
    System.out.println("Hello");
}
else if (x % 3 == 0) {
    System.out.println("Welcome");
}
else if (x % 5 == 0 && x % 3 == 0) {
    System.out.println("Hello Welcome");
}
else {
    System.out.println("invalid number");
}


Why This Code Is Wrong?

For x = 15

x % 5 == 0 → true

Program prints "Hello"

The condition x % 5 == 0 && x % 3 == 0 is never reached

--More specific condition is placed after less specific condition

--Order of conditions is incorrect


Correct code:
-------------

int x = 15;

if (x % 5 == 0 && x % 3 == 0) {
    System.out.println("Hello Welcome");
}

else if (x % 5 == 0) {
    System.out.println("Hello");
}

else if (x % 3 == 0) {
    System.out.println("Welcome");
}

else {
    System.out.println("invalid number");
}



--In if-else ladder, always write the most specific condition first and the most general condition last.


**************************************************************************************************************************************



Functions of JVM (Java Virtual Machine):
-----------------------------------------

--The JVM (Java Virtual Machine) is responsible for executing Java programs.

Main Functions of JVM:
----------------------

1. Bytecode to Machine Code Conversion:

--JVM converts the required part of the bytecode (.class file) into its equivalent native machine code.

--This conversion is done using:

* Interpreter

* JIT (Just-In-Time) Compiler

2. Loading Code into Memory: 

--JVM loads the required bytecode into RAM using the Class Loader Subsystem.

3. Execution of Code:

--The converted machine code is executed with the help of the underlying Operating System (OS) and hardware.

4. Memory Management:

--JVM automatically manages memory using:

-Heap allocation

-Stack frames

-Garbage Collection (GC)

5. Removal of Unused Objects

--JVM removes unused objects from memory using Garbage Collector, freeing RAM.



Platform Dependency of JVM:
---------------------------

--JVM is platform dependent.

Reason:

--A JVM running on Windows generates machine code specific to Windows OS.

--A JVM running on Linux generates machine code specific to Linux OS.

Important Note:

--Java programs are platform independent.

--JVM is platform dependent.


Java Packages:
==============

--A package in Java is a namespace that groups related classes and interfaces in a single unit.

--A package is used to bind the related concept logically.


Purposes of Packages: 

1. Logical Grouping

--Groups related classes and interfaces together.

2. Namespace Management

--Prevents naming collisions (same class name in different packages).

Example:

com.chitkara.Demo
com.masai.Demo

3. Access Control / Security

--To provide some level of security with the help of access modifiers

--Will discuss about this concept in upcoming sessions when we talk about the access modifiers and inheritance concept.



Commonly Used Java Packages:
---------------------------



java.io: Contains classes and interfaces used for Input and Output operations. Example: File, InputStream, OutputStream, BufferedReader

java.util: Containts all the utility related classes like ArrayList, LinkedList, HashMap, Scanner, Date

java.sql: Contains all the classes/interfaces related to perform Database operations.

**java.lang: all the basic/core classes available inside this package.

Example: 

System
String
Object
all the Wrapper classes (Integer, Float, Byte...)


--If we try to use a class which belongs to a different package inside our class, then we must import that class from that package.

--java.lang package is a default package, and in order to utilize this package related classes inside our class we need not import this package, this package is by default imported in every Java class.



Note: In Java the fully quailified name of a class or interface we call it with the help of its package name

java.lang.System
java.util.ArrayList

com.chitkara.Demo

********************************************************************************************************************************

Note: Java uses IEEE 754 floating-point representation, which standardizes how computers encode real numbers using 32-bit (single) or 64-bit (double) binary formats, consisting of a sign bit.It enables efficient, uniform storage of very large or small numbers using normalized scientific notation


		String s1 = "10";
		String s2 = "20";
		
		int n1=  Integer.parseInt(s1);
		int n2 = Integer.parseInt(s2);
		
		System.out.println(n1+n2);
		




Example1:

char c= 'a';

//byte b = c;









Example2: 

byte b1 = 10;

//byte b2 = b1+1;


Example3:

byte b1= 10;

byte b2 = b1++;


System.out.println(b1);
System.out.println(b2);



Example4:

byte b1= 10;
byte b2= 20;

//byte b3 = b1+b2;


Rule: 

max(int, type1, type2, ....)


********************************************************************

Types variables inside a java class:
------------------------------

1. local variables: defined inside any methods. JVM will allocate memory of these local variables inside the Stack Area.

2. Instance variables/non-static variables: These variables belongs to Object and it will be allocated inside the Heap Area
at time of Object creation.

--The non-static variables are the Object level variables, and each object has their own copy of the non-static variables.


3. static /class level variables: JVM will allocate these variables inside the method area at time of loading a .class file along with class level metadata. at this time only these variables will be initialized.

Note: Static variables belongs to the class and it is sharable among multiple objects.

 





Basic Rule of Computer Execution:

--The CPU can execute only those instructions and data which are present in RAM.

Hard Disk → Permanent storage

RAM → Temporary working memory

CPU → Executes data present in RAM only

--If something is not in RAM, CPU cannot execute it.


Static Loading vs Dynamic Loading:
====================================

Static Loading (Example: C Language):
------------------------------------

--A block of code would be loaded into the RAM before it is executed, after being loaded into the RAM it may or may not get executed.

--In static loading, the entire application is loaded into RAM (actual memory is allocated) before execution starts.

--Memory is allocated for the whole program, regardless of whether all parts are executed or not.




Example:

app1.c
-------

c program:{

1000 variable
10000 methods/function

}


--When app1.c runs, the entire executable is loaded into RAM.

--Execution happens line by line, but memory allocation is already done.

--This approach is commonly seen in procedural languages like C.



Dynamic Loading:
----------------


--A block of code would be loaded into the RAM only when it is required to be executed.

--Java follows dynamic class loading and dynamic memory allocation.



Example: Java application

Demo.java:

class Demo{

1000 variables

10000 methods/function

}



Demo.java -----> compile(java compiler)----->Demo.class---while executing,

--First of all the JVM program will be loaded into the RAM.

--Now JVM will load the .class file metadata(structure of the class) into the Method Area (by the ClassLoaded subsystem).

--After this JVM will load (allocate the memory) only for the required part of the program, for the remaining parts the actual memory allocation will not happen(not loaded).

--Whenever it is required, at that time we can allocate the memory for the other part of the program dynamically and execute them.

--Here the required parts are static members.

--Generally there are 2 categories of members of a Java class

1. variables
2. methods


--we can categorise these members into furthur 2 categories:

1. static members
2. non-static members
 
--After counting the members inside a class, we need to identify the types of the members (i.e static or non-static)

--The members where 'static' keyword is applied is known as static member and for which it is not applied is known as non-static.

--While executing a Java application, all the static members will be loaded into the RAM (actual memory is allocated) and they will be available to the CPU , where as for the non-static the actual memory allocation will not happen.

--After loading all the static members, JVM searches the main method among these static members.

public static void main(String[] args)

--Since the main method is a static member, and it is already loaded(memory is allocated), it is available to the CPU, and JVM will starts the execution of a Java program from the first line of the main method.
 


Java Program Execution Flow:
============================

Step 1: JVM Loading

--When a Java program is executed, first the JVM is loaded into RAM.


Step 2: Class Loading

--The ClassLoader subsystem loads the .class file.

--The following class metadata is stored in the Method Area:

-Class structure (blueprint)

	-Method bytecode

	-Static variables

	-Static methods

	-Runtime Constant Pool: The Runtime Constant Pool stores constant values and symbolic references required during program execution.

Step 3: Static Member Initialization

--Static variables are allocated memory and initialized.

--Static methods become available to the CPU.

Step 4: Main Method Execution

--JVM searches for:

public static void main(String[] args)


--Since main() is static, it is already loaded.

--Program execution starts from the first line of main().




--To access the non-static members in main method, we need to allocate the memory (load) the non-static members by creating object of that class.

Requirement of creating an object: 

--To allocate the memory of the non-static members (load) into the RAM dynamically we need to create instance/object of that class.




Ex:

Demo.java:
-------------

package com.masai;

public class Demo {
	
	//instance variable
	int i=100;
	
	//static or class variable
	static  int j =200;
	
	//non-static
	void fun1() {
	
		System.out.println("inside fun1 of Demo");
		//10000
	}
	
	static void fun2() {
		System.out.println("inside fun2 of Demo");
		
	}
	

	public static void main(String[] args) {
		 
		//local variable
		//int x= 10;
		
		//System.out.println(j);
		
		System.out.println("inside main");
		
		//creating object of a class
		//instantiating a class
		Demo d1 = new Demo();
		
		System.out.println(d1);
		
		System.out.println(d1.i);
		
		d1.fun1();
		
		//fun1();
		
		//fun2();
		 
		 
	}

}



functionality of 'new' operator:
================================

1. Whenever the Jvm encounters 'new' operator, it will reserve a memeory space inside the Heap area.

2. inside that memory space, it will load all the non-static members of that class.

***while loading the non-static methods, it will load only the method name/signature and its address, it will not load method body, method body will be loaded at run time when we call that method.

***while loading the non-static variables, inside that reserved memory space (Heap area), if variable are not initialized then the JVM will provide the default value to those non-static variables.

Note: default value will not be given to the local variables, we can not use uninitialized local variable in our application, it will raise an compilation error.


Note: we can create multiple objects for a perticular class,and modification done in one object will not reflect to another object.


***Technically, an object of a class is a memory space inside the Heap Area where non-static elements are loaded.


Demo d1 = ?


--for a class ref variable 3 possible values are there:

1. its own class object.

Demo d1 = new Demo();

2. its child class object:-

Demo d1 = new DemoChild(); // it is possible only if DemoChild class is the child class of Demo class.

--this concept is also known as super class reference and child class object.

3. default value for any ref variable. i.e null.

Demo d1 = null;



JVM Memory Areas (Simplified View):
-------------------------------------

--JVM manages RAM by dividing it into logical memory areas:

1. Method Area

Class structure

Static variables

Static methods

Method bytecode

2. Heap Area

Objects

Instance variables

3. Stack Area

Method calls

Local variables

References

--All these areas are inside RAM.





example:

Demo.java:
----------------

package com.masai;

public class Demo {
	
	//instance variable
	 int i;
	
	//static or class variable
	static  int j =200;
	
	//non-static
	 void fun1() {
	
		System.out.println("inside fun1 of Demo");
		//10000
	}
	
	static void fun2() {
		System.out.println("inside fun2 of Demo");
		
	}
	

	public static void main(String[] args) {
		 
		
		
		Demo d1 = new Demo();//here d1 is a reference variable, d1 is pointing to the Demo class obj.
		
		d1.i=100;
		
		System.out.println(d1.i);//100
		
		Demo d2 = d1;
		
		System.out.println(d2.i); //100
		
	}

}



Note: one object(memory space) can be refered by multiple variables simulteniously, but one variable can not refer multiple object simulteniously.


--The object which is not referenced by any reference variable will be treated as garbage, and in Java there is a seperate thread running continuously, called Garbage collector, the duty of this garbage collector is to clean that un-referenced object and free the RAM.


--If any one variable holding the address of any object then that object is not treated as garbage.


--from the null, if we try to access any value(non-static) or call any method(non-static), then we will get a runtime exception called NullPointerException.



example:


		Demo d1 = new Demo();//here d1 is a reference variable, d1 is pointing to the Demo class obj.
		
		d1.i=100;
		
		Demo d2 = d1;
		
		d1= null;
		
		System.out.println(d2.i);//100
		
		// till this line no any obj is eligible for GC.
		
		
--primitive variables having their seperate copies:

ex:

		int x = 10;
		
		int y =x;
		
		System.out.println(x); // 10
		System.out.println(y); //10
		
		x = 200;
				
		System.out.println(x); // 200
		System.out.println(y); // 10


--Where as object if reassigned to difference variables then all variables will points to the same copy.

ex2:

		Demo d1 = new Demo();
		
		Demo d2 = d1;
		
		System.out.println(d1.i); //0
		System.out.println(d2.i); //0
		
		d1.i=500;
		
		System.out.println(d1.i); //500
		System.out.println(d2.i); //500


ex3 :

		Demo d1 = new Demo();
		d1.fun1();
	
		//another approach of calling a method	
		new  Demo().fun1();
		
		d1.fun1();
		
		d1.fun1();
		
		System.out.println(d1.i);


State of an object:  The data present inside the object at that instance of time is known(what an object knows) as state of the object.

Behaviour of an object: functionality that are applicable to that object (what an object can do) is known as behaviour of an object.

Example:



Song.java:
------------

package com.masai;

public class Song {
	
	String artist;
	String title;
	
	void play() {
		
		System.out.println(artist+" is singing "+title);
	}
	
	
	public static void main(String[] args) {
		
		Song track1 = new Song();
		track1.artist="Lata";
		track1.title="Wande Matram";
		
		track1.play();
		
		Song track2 = new Song();
		track2.artist="Sukhwindar";
		track2.title="Jai Ho";
		
		track2.play();
				
	}

}


Example2:


Student.java:
--------------

package com.chitkara;

public class Student {
	
	int roll;
	String name;
	double marks;
	
	static String collageName;
	
	void displayDetails() {
		
		System.out.println("Roll is : "+roll);
		System.out.println("Name is : "+name);
		System.out.println("Marks is : "+marks);
		System.out.println("Collage Name is: "+collageName);
		
		System.out.println("========================");
	}
	
	
	public static void main(String[] args) {
		
		
		collageName = "Chitkara";
		
		Student student1 = new Student();
		student1.roll= 10;
		student1.name= "Raj";
		student1.marks = 780.00;
		
		Student student2 = new Student();
		student2.roll= 20;
		student2.name= "Simran";
		student2.marks = 880.00;
		
		student1.displayDetails();
		student2.displayDetails();
		
		
	}

}


Note: static member are available to the non-static as well as static members, becasue memory is already allocated for the static members.

--same copy of the static variables are sharable among all the objects.

--where as to access non-static members inside the static area we need to create object of that class.





*****************************************************************************


Demo.java:
---------------

package com.masai;

public class Demo {
	
	int x = 100;
	
	Demo d1 = new Demo();
	
	//A a1 = new A();

	public static void main(String[] args) {
		 
		Demo d1 = new Demo();
		
		
		
	}

}


--the above application will throw a runtime exception called StackOverFlowError exception.

Demo.java:
------------

package com.masai;

public class Demo {
	
	int x = 100;
	
	Demo d1;
	
	//A a1 = new A();

	public static void main(String[] args) {
		 
		Demo d1 = new Demo();
		
		System.out.println(d1.d1);//null
		
		d1.d1=new Demo();
		
		System.out.println(d1.d1.x);
				
	}

}







