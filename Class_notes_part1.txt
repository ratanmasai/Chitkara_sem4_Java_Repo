Any computer program mainly consists of two parts:

1. Data → Variables

2. Logic → Functions / Methods

--Among these two, data is the most critical part, because:

-Logic can be rewritten

-But data loss or corruption is dangerous


Problem with Procedural / Structured Programming:
-------------------------------------------------

In procedural or structured programming languages (like C/C++):

--Data is often declared as global variables

--Global variables can be accessed and modified by any function

--This leads to high data insecurity

Example: Banking Application (Procedural Style)


// bankingApp.cpp

string customerName;
int accountNumber;
int balance;
string branchName;

void withdraw(int amt) {
    balance = balance - amt;
}

void deposit(int amt) {
    balance = balance + amt;
}

void transferAmount(int src, int dest, int amt) {
    // transfer logic
}

void login() {
    // authentication & authorization
}

void logout() {
}

void changePassword() {
    // unrelated function accessing unrelated data
    balance = balance - 5000;
}



Problems in Above Code:
-----------------------

--balance is globally accessible

--Any function (even unrelated ones) can modify it

Example: changePassword() modifying balance

Leads to:

--Data corruption

--Security issues

--Poor maintainability


To secure data, programmers designed a mechanism where:

--Data and the functions that operate on that data are bound together inside a single unit.

--This unit is called a Class.

--This concept is known as Encapsulation.



Object-Oriented Solution Using Encapsulation:
---------------------------------------------


class Account {

    private String customerName;
    private int accountNumber;
    private int balance;
    private String branchName;

    void withdraw(int amt) {
        balance = balance - amt;
    }

    void deposit(int amt) {
        balance = balance + amt;
    }

    void transferAmount(int src, int dest, int amt) {
        // transfer logic
    }
}


class Authentication {

    void login() {
        // authentication & authorization
    }

    void logout() {
    }

    void changePassword() {
        // cannot access Account balance directly
    }
}



Key Observations:

1. Data Security

--balance is private

--Cannot be accessed outside Account class

--Only related methods can modify it

2. Separation of Responsibility

--Account → Financial operations

--Authentication → Login / security operations

3. No Global Variables

--Variables inside a class are not global

--They are also not local to a single method

--Hence, they are called Instance Variables


Pure Encapsulation:
-------------------

--A class is said to be purely encapsulated when all data members are declared as private.

--Account class is a purely encapsulated class

--It acts as a blueprint

--Multiple objects (accounts) can be created with different states



Definition of Encapsulation:
-----------------------------

--Encapsulation is the process of binding data along with its corresponding functionalities and restricting direct access to data to ensure security.



Purpose of Encapsulation:
-------------------------

--Data security

--Controlled access

--Better maintainability

--Modular design



Java supports all the 4 pillers of  OOP concepts:

1. Encapsulation

2. Inheritance

3. Polymorphism

4. Abstraction

Hence, Java is an Object-Oriented Programming language



Note: C++ also supports encapsulation but it also allows:

--Global variables

--Global functions

Therefore, C++ is not considered a pure OOP language

--Java avoids this by forcing everything inside classes



--Encapsulation was the first step in the evolution of OOP

--It protects data from unauthorized access

--It eliminates the problems of global variables

--It forms the backbone of Object-Oriented Programming






JDK and OpenJDK:
----------------

To develop and run a Java application, we need to install a software called the JDK (Java Development Kit).

--The official JDK is provided by Oracle through its website.

--Oracle JDK is free for development, but license required for some production use.

--Apart from Oracle, many other vendors also provide their own JDK distributions.

Some popular JDK vendors are:

-Amazon Corretto

-Azul Systems

-Eclipse Temurin (Adoptium)

-IBM Semeru JDK

-Red Hat OpenJDK


Example: Amazon Corretto JDK Installation

--If Amazon Corretto JDK is installed, the environment variables are usually set as:

JAVA_HOME = C:\Program Files\Amazon Corretto\jdk21.0.9_10
Path      = C:\Program Files\Amazon Corretto\jdk21.0.9_10\bin


--JAVA_HOME points to the JDK installation directory

--Path allows us to run Java commands (java, javac) from anywhere in the terminal


Java Editions (Categories):

--Java is divided into three main editions:

1. Java SE (Standard Edition)

--Also called Core Java

--Provides fundamental APIs such as OOP, collections, multithreading, exception handling, JDBC, etc.

2. Java EE (Enterprise Edition) (now called Jakarta EE)

--Also known as Advanced Java

--Used for enterprise and web applications

--Built on top of Java SE

3. Java ME (Micro Edition)

--Used for embedded systems and resource-constrained devices


Note: Java SE is the base edition for both Java EE and Java ME.


Java as a Specification:
------------------------

--All Java editions (SE, EE, ME) are specifications, not direct software.

--A specification is a detailed document that defines:

-Rules

-APIs

-Behavior

-Guidelines to develop Java software

--Java SE Specification defines what features a Java SE platform must support.


JDK and OpenJDK:
----------------

--The implementation of the Java SE specification is called the JDK.

--OpenJDK is the reference implementation of the Java SE specification.

--Most vendors (Oracle, Amazon, Azul, etc.) build their JDKs using OpenJDK source code, with some additional optimizations or support.



Analogy:
--------

CBSE Syllabus:	Java SE Specification
NCERT Book:	OpenJDK (Reference Implementation)
Other Publishers’ Books	Vendor JDKs (Amazon Corretto, Oracle JDK, etc.)


Just like:

--NCERT strictly follows the CBSE syllabus

--OpenJDK strictly follows the Java SE specification

--Other publishers/vendors release their own versions based on the same standard


******************************************************************************************************************

Java First Program

Program1.java
--------------

class Demo {

    public static void main(String[] args) {
        System.out.println("Welcome to Chitkara");
    }

}


Java Class Naming Convention:
-----------------------------

--Java class names should start with a capital letter.

--Java follows PascalCase (PascalNaming Convention) for class names.


Examples:

class StudentDetails { }
class BankAccount { }


Tip: In Java applications, anything that starts with a capital letter is usually (almost always) a class or an interface.


Phases of Java Program Execution:
----------------------------------

--To execute a Java program, there are two phases:

1. Compilation Phase

2. Execution (Run) Phase


(source code)	compiler			(byte code)	
.java----------->compile----------------------->.class------------>executed by the JVM
		 javac 							java ClassName
		javac file_name.java


Command to compile:
-------------------

javac FileName.java



Bytecode and JVM Execution:
---------------------------

--The .class file contains bytecode.

--Bytecode is executed by the JVM (Java Virtual Machine).




Multiple Classes in a Single .java File:
----------------------------------------

--A single .java file can contain multiple classes.

--For each class, the compiler generates a separate .class file.

Example

Program1.java
-------------

class Demo1 {

    public static void main(String[] args) {
        System.out.println("Welcome to Chitkara1");
    }
}

class Demo2 {

    public static void main(String[] args) {
        System.out.println("Welcome to Chitkara2");
    }
}

class Demo3 {

    public static void main(String[] args) {
        System.out.println("Welcome to Chitkara3");
    }
}



After Compilation:
------------------

Demo1.class
Demo2.class
Demo3.class


Execution:
----------

java Demo1
java Demo2
java Demo3


--Only one class is executed at a time
--That class must contain main()


Empty Java Class:
-----------------

--A Java class can exist without any members.

--An empty class is syntactically valid, but cannot be executed.

Example:

class Demo {
    // Empty class
}


.class file will be generated
--Cannot run (no main() method)


main() Method Rule:
------------------

--Only classes containing:

public static void main(String[] args)


--can be executed using the java command.


public Class and File Name Rule:
-------------------------------

--A .java file can contain only one public class

--If a class is declared as public:

--File name must be same as the public class name



Best Practice:
--------------

--Generally, we write one class per .java file

Makes code:

--Readable
--Maintainable
--Industry-standard


JDK, JVM, and JRE:
------------------

Platform Independence

--Java is platform independent

--JVM is platform dependent

Why?

--Java programs compile into bytecode

--Bytecode is independent of OS

--JVM converts bytecode into OS-specific machine code


.class  ---> JVM  ---> OS Executable Code


--Same .class file can run on:

Windows
Linux
macOS
(as long as JVM is available)





************************************************************************


IDE installation:
-----------------

Eclipse




Similarity of Java with Other Programming Languages:
-----------------------------------------------------

--Most of the common and fundamental programming concepts in Java are very similar to those found in other popular programming languages such as C, C++, and Python.

--These similarities make Java easy to learn, especially for students who already have basic programming knowledge.

--This helps programmers focus on object-oriented concepts rather than struggling with syntax.

--Because of this similarity, transitioning from C/C++ to Java is relatively smooth.



1. Operators:

Java supports almost the same types of operators as other programming languages:

Arithmetic Operators: +, -, *, /, %

Relational Operators: >, <, >=, <=, ==, !=

Logical Operators: &&, ||, !

Assignment Operators: =, +=, -=, *=, /=

Increment / Decrement Operators: ++, --

--These operators behave almost the same way as in languages like C and C++.


2. Conditional Statements (if, if-else, else-if):

Decision-making statements in Java follow a syntax and logic similar to other languages.

Example:


int age = 20;

if (age >= 18) {
    System.out.println("Eligible to vote");
} else {
    System.out.println("Not eligible to vote");
}


--The working of if, if-else, and else-if is conceptually identical to C/C++.


3. Looping Statements:

--Java provides looping constructs that are almost identical to those in other languages.

for Loop
--------

for (int i = 1; i <= 5; i++) {
    System.out.println(i);
}


while Loop:
----------

int i = 1;

while (i <= 5) {
    System.out.println(i);
    i++;
}



do-while Loop:
---------------

int i = 1;

do {
    System.out.println(i);
    i++;
} while (i <= 5);


--The logic and flow of loops remain same across most languages.



4. Identifiers:

--Identifiers are the names given to program elements such as:

Variables

Methods

Classes

Objects

--Rules for identifiers in Java are very similar to other languages:

1. Must start with a letter, _, or $

2. Cannot start with a digit

3. Cannot be a keyword

4. Are case-sensitive








Note: in java, local variable must be initialized before we use it.

	//local variable 	
		int z;
		
		z=100;
		
	System.out.println(z);
		

Example of conditional statements:
----------------------------------

Using if-else:

Demo.java:
----------


class Demo{

	public static void main(String[] args){

		
		int marks = 500;

		 if(marks > 600)
			 System.out.println("First Div");
		 else
			 System.out.println("Second Div");

	}

}


Without else part:


class Demo{

	public static void main(String[] args){

		
		int marks = 500;
		String result = "First Div";

		 if(marks > 600)
			 result = "Second Div";
		 
		System.out.println(result);

	}

}


Without if-else:
----------------


class Demo{

	public static void main(String[] args){

		
		int marks = 500;


		String result = (marks > 600) ? "First Div" : "Second Div";

		System.out.println(result);
			
	}

}


Task:

int x = 2;

if x value is divisible by 5 then print "Hello"  // 10
if x value is divisible by 3 then print "Welcome" // 9 
if x value is divisible by 5 and 3 then print "Hello Welcome"  // 15,30
if x value is not divisible by 5 and 3 then print "invalid number" //2,11





Solution1: 


int x = 15;

if (x % 5 == 0) {
    System.out.println("Hello");
}
else if (x % 3 == 0) {
    System.out.println("Welcome");
}
else if (x % 5 == 0 && x % 3 == 0) {
    System.out.println("Hello Welcome");
}
else {
    System.out.println("invalid number");
}


Why This Code Is Wrong?

For x = 15

x % 5 == 0 → true

Program prints "Hello"

The condition x % 5 == 0 && x % 3 == 0 is never reached

--More specific condition is placed after less specific condition

--Order of conditions is incorrect


Correct code:
-------------

int x = 15;

if (x % 5 == 0 && x % 3 == 0) {
    System.out.println("Hello Welcome");
}

else if (x % 5 == 0) {
    System.out.println("Hello");
}

else if (x % 3 == 0) {
    System.out.println("Welcome");
}

else {
    System.out.println("invalid number");
}



--In if-else ladder, always write the most specific condition first and the most general condition last.


**************************************************************************************************************************************



Functions of JVM (Java Virtual Machine):
-----------------------------------------

--The JVM (Java Virtual Machine) is responsible for executing Java programs.

Main Functions of JVM:
----------------------

1. Bytecode to Machine Code Conversion:

--JVM converts the required part of the bytecode (.class file) into its equivalent native machine code.

--This conversion is done using:

* Interpreter

* JIT (Just-In-Time) Compiler

2. Loading Code into Memory: 

--JVM loads the required bytecode into RAM using the Class Loader Subsystem.

3. Execution of Code:

--The converted machine code is executed with the help of the underlying Operating System (OS) and hardware.

4. Memory Management:

--JVM automatically manages memory using:

-Heap allocation

-Stack frames

-Garbage Collection (GC)

5. Removal of Unused Objects

--JVM removes unused objects from memory using Garbage Collector, freeing RAM.



Platform Dependency of JVM:
---------------------------

--JVM is platform dependent.

Reason:

--A JVM running on Windows generates machine code specific to Windows OS.

--A JVM running on Linux generates machine code specific to Linux OS.

Important Note:

--Java programs are platform independent.

--JVM is platform dependent.


Java Packages:
==============

--A package in Java is a namespace that groups related classes and interfaces in a single unit.

--A package is used to bind the related concept logically.


Purposes of Packages: 

1. Logical Grouping

--Groups related classes and interfaces together.

2. Namespace Management

--Prevents naming collisions (same class name in different packages).

Example:

com.chitkara.Demo
com.masai.Demo

3. Access Control / Security

--To provide some level of security with the help of access modifiers

--Will discuss about this concept in upcoming sessions when we talk about the access modifiers and inheritance concept.



Commonly Used Java Packages:
---------------------------



java.io: Contains classes and interfaces used for Input and Output operations. Example: File, InputStream, OutputStream, BufferedReader

java.util: Containts all the utility related classes like ArrayList, LinkedList, HashMap, Scanner, Date

java.sql: Contains all the classes/interfaces related to perform Database operations.

**java.lang: all the basic/core classes available inside this package.

Example: 

System
String
Object
all the Wrapper classes (Integer, Float, Byte...)


--If we try to use a class which belongs to a different package inside our class, then we must import that class from that package.

--java.lang package is a default package, and in order to utilize this package related classes inside our class we need not import this package, this package is by default imported in every Java class.



Note: In Java the fully quailified name of a class or interface we call it with the help of its package name

java.lang.System
java.util.ArrayList

com.chitkara.Demo

********************************************************************************************************************************

Note: Java uses IEEE 754 floating-point representation, which standardizes how computers encode real numbers using 32-bit (single) or 64-bit (double) binary formats, consisting of a sign bit.It enables efficient, uniform storage of very large or small numbers using normalized scientific notation


		String s1 = "10";
		String s2 = "20";
		
		int n1=  Integer.parseInt(s1);
		int n2 = Integer.parseInt(s2);
		
		System.out.println(n1+n2);
		




Example1:

char c= 'a';

//byte b = c;









Example2: 

byte b1 = 10;

//byte b2 = b1+1;


Example3:

byte b1= 10;

byte b2 = b1++;


System.out.println(b1);
System.out.println(b2);



Example4:

byte b1= 10;
byte b2= 20;

//byte b3 = b1+b2;


Rule: 

max(int, type1, type2, ....)


********************************************************************

































